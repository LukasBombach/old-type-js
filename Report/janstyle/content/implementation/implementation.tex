%!TEX root = ../../thesis.tex

\section{JavaScript library development}

% There are many popular frameworks and libraries that provide a structure, rules and conventions for implementing websites and web applications. 

No IDEs, tools, not even conventions. Es gibt frameworks die eine architektur für webseiten und web-applikationen vorgeben, aber nichts dergleichen für bibliotheken.

Not for building:
Big JS libraries all do it differently.
Top 3 client side JavaScript repositories (stars) on github
https://github.com/search?l=JavaScript\&q=stars\%3A\%3E1\&s=stars\&type=Repositories
Angular.js: Grunt
d3 Makefile, also ein custom build script welche node packages aufruft
jQuery custom scripts, mit grunt und regex und so

Not for Architecture
Angular custom module system with own conventions
d3 mit nested objects (assoc arrays) und funktionen
jQuery mit .fn
ACE mit Klassen, daraus habe ich gelernt

ES5 oder ES6?


\section{Ich habe verwendet}

Gulp
requireJs
AMDClean
Uglify

JSLint - Douglas Crockford coding dogmatas / conventions
JSCS - JavaScript style guide checker

~~Livereload~~
PhantomJs
Mocha
Chai

Durch Require und AMDClean schöne arbeitsweise (am ende über bord geworfen) und kleine Dateigröße, wenig overhead.

Automatisierte Client side Tests mit PhantomJs und Mocha/Chai


\section{Coding conventions}

Habe mich größtenteils an Crockfordstyle orientiert, aber die Klassen anders geschrieben. Habe den Stil von ACE editor verwendet, denn der ist gut lesbar. Lesbarkeit war mir wichtiger als Crockford style. Für private Eigenschaften und Methoden habe ich die prefix convention verwedendet.
https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor\_s\_Guide/Private\_Properties
Sie bewirkt keine echte accessibility restriction, aber es ist eine allgemein anerkannten convention und ist auch viel besser lesbar.

\section{Architecture}

%Modulbasiert?
%Erweiterbarkeit
%Es gibt ein Basisobjekt, das ist die Type "Klasse".
%Darin werden dann die anderen Klassen geschrieben "Type.Caret", "Type.Selection", "Type.Range", ...
%Das hat den Vorteil dass das ganze ge-name-spaced ist, so dass ich keine Konflikte mit Systemnamen habe (Range) (und auch nicht mit anderen Bibliotheken)
%Effektiv gibt es eine (flache) Baumstruktur und so mit Ordnung. Für bestimmte Klassen, "Type.Event.Input", "Type.Input.Filter.X" geht es tiefer.
%Der zweite Grund ist, dass ich somit alle Klassen die ich geschrieben habe für Entwickler sichtbar bereit stelle und nicht implizit und versteckt über irgend nen Quatsch.

%Auch angedacht so wie der CKEditor (?) die komplette funktionalität als Plugins zu schreiben. Im Besten Fall

\subsection{Model--view--controller}

Model--view--controller (MVC) is a common apprach for implementing user interfaces and it can be applied to user interface components too. While this apporach can provide clear responsibilites, the problem is that most components, like the caret or the selection, serve a clear atomic purpose and would need to be broken apart into model, view and controller parts themselves, making the architecture fuzzy and complex instead of simplifying it. Following the MVC architecture, the contents of the editor (the text) can be represented in a model (holding the text data and allowing methods to be performed on) and be rendered with a view (displaying the text in the browser). As discussed in \refsection{sec:api_design}, the library shall leave as much freedom as possible to the developers. In and MVC system like this, the contents of the editor could only be changed though the API, since arbitrarily modifying the HTML of the editor's contents would change the view, but not the model. This would create an artificial bottleneck, which cannot be desired.

%The biggest advantage of this approach would be that an abstract view layer could not only render rich-text as HTML, but also as Markdown or in the Open Document Format (ODF). Atom, Spotify or Wunderlist show that web technologies find their way into desktop. Writing to custom formats 
%While especially the latter is not useful in a browser environment


%Ursprünglich ein MVC konzept geplant mit einem Document Model und verschiedenen Renderern, aber über den haufen geworfen.

%\subsection{Modular programming}

\section{Modular and object-oriented programming}

jQuery and CKEditor demonstrate a software architecture in which a core object mainly provides a system to extend its functionality, but does not offer many methods itself\footnote{CKEditor provides a framework for implementing components for it, but does not offer any rich-text functionality in its core. jQuery provides low-level utility methods for JavaScript.}. The actual functionality of both libraries is implemented through extensions while the libraries are usually bundled with a set of ''core extensions'' that provide basic features. CKEditor makes use of modular programming by implementing a major part of its editor as plugins that communicated via well-defined interfaces. jQuery established a paradigm calling any extension a ''plugin'' but instead of using clearly defined interfaces, developers are encouraged to add arbitrary methods to jQuery's base object, which can then be directly accessed. Extending a base object has many advantages

\begin{enumerate}
\item It provides a namespace for the library
\item It provides a structure for extensions to access each other
\item It approaches modular programming and strong decoupling
\end{enumerate}

Modular programming could create a system in which other developers could exchange any component easily to improve performance or enrich functionality. The disadvantage this apporach would be that the need for well-defined interfaces can diminish flexibility. Formalizing interfaces would create complex structures and could make it harder for other developers to contribute to the library instead of inviting them. jQuery goes the opposite direction and encourages arbitrary extensions. jQuery's approach demonstrates that this flexibility, in practice, can withstand possible conflicts. In turn, the low barrier for extending jQuery has spawned a rich collection of extensions and a big community of developers. While jQuery allows to be extended with complex libraries, it is designed to be extended with simple methods. It is difficult to establish complex interactions between extensions.

% However, the biggest factor in coupling the components would still be that components reference each other, not the underlying structure. 

To close the gap between CKEditors modular programming approach and jQuery's simple extension paradigms, object-oriented programming (OOP) can be used. JavaScript does not offer classes and classical inheritance, however the same functionality can be achieved using the constructor pattern and prototypal inheritance. Functions used as constructors will be called classes hereinafter.

For this library a base class will provide the namespace to be extended with other classes implementing the functionality of this library. A set of core extensions provide all components needed for a rich-text editor. The base class will also provide a constructor that will be the library's entry point for other developers to implement a rich-text editor. The base class and its extensions will be discussed in detail in section \refsection{sec:mudules}. Implementing the library's functionality in classes has many benefits:

\begin{enumerate}
\item Classes are a proven concept for encapsulating functionality and data, protecting access and structing code as well as making it readable
\item Through JavaScript's prototypical inheritance, a class' implementation only exists once per website, regardless how often it has been instantiated, thus saving memory and improving performance
\item Instance variables still allow to reuse a class in different contexts with different inherent data %Die instanzvariablem sind meistens nur Pointer auf Instanzen anderer Klassen % * Das ganze ist dadurch sehr schlank
\end{enumerate}

As an alternative apporach, the module pattern can be used, which would also allow namespacing, encapsulation and protected access, but would make an implementation similar to instance variables much more complicated and be much less readable in general.

%namespace vorteile = keine namenskonflikte

% and implement as many components as possible as plugins. In its core, the library could create an environment to allow plugins to register and interact with each other. This would 


\section{Module architecture}

This section discusses how the responsibilites of the modules of ''Type'' and how they interact with each other. The implementations and characteristics of each module will be discussed hereinafter.

directed acyclic graph ? 

\section{Modules}
\label{sec:mudules}

\subsection{Type}

Die Type

\subsection{Range}
range



\subsection{Input}

%82.78\% of internet users support listening to and reading clipboard events. I can support 100\% PROBLEMS

There are many devices (hardware and virtual) a user can interact with native inputs:

\begin{enumerate} 
\item Keyboard (as hardware and as virtual keyboard)
\item Mouse
\item Touch
\item Game controller (on browsers imlpemented in game consoles)
\item Remote control (on Smart TV einvironments)
\end{enumerate}

When simulating a native input, in a best-case scenario, all these input methods should be accounted for. Fetching input needs to account for two scenarios: The user clicks / touches / or selects the input in any way and does so at any position inside the input. If the user touches / clicks / etc in the middle of the text, the caret should move to that position and typing must be enabled. In environments without hardware keyboards, the libarary must ensure that a virutal keyboards, possible native to the system, show up. Once the input is selected, text input must be fetched and written to the editor. There are various options to fetch user input, which will be discussed in the following paragraphs:

\subsection{Events} One way to fetch user input is by listening to events. Text input can be read through \texttt{KeyboardEvent}s. Keyboard events will be triggered for virtual keyboards just as for hardware keyboards. When the user presses a key, the event can be stopped and the according characters can be inserted at the position of the caret. As a downside, listeners for keyboard events cannot be bound to a specific element that is not a native text input, that means keyboard events must be listened to on the \texttt{document} level. This not only has (minor) performance downsides but als requires more logic to decide whether a keyboard input should be processed and ultimatively stopped or ignored and allowed to bubble to other event listeners of a website. Furthermore, there can be edge cases, where even though a keyboard event should write contents to the editor, the event itself is supposed to trigger other methods that are not part of the editor. Keyboard events are supported by all major browsers across all devices.

To support clicking or touching inside the editor's contents \texttt{MouseEvent}s and \texttt{TouchEvent}s can be used. Mouse events are supported on all major desktop browsers and all mobile browsers support touch events. Both event types support reading the coordinates indicating where the click or touch has been performed.

Although some smart TVs offer keyboards, mice, pointers similar to Nintendo's Wii remote, input via smartphone apps and many others, button-based remote controls are offered with almost any smart TV and remain a edge case for interacting with a text editor. In such an enviroment, users commonly switch between elements by selecting focusable elements with a directional pad. Using only events would not account for this case since there would be no focusable element representing the editor. Recent browsers on Samsung's and LG's smart TVs are based on WebKit\footnote{\url{http://www.samsungdforum.com/Devtools/Sdkdownload}, last checked on 07/22/2015} while Sony's TVs use Opera. Before 2012 Samsung's browser was based on Gecko. All of these browsers and browser engines supprt keyboard events to fetch input.

\subsection{Clipboard} Another problem with relying entirely on events is the lack of native clipboard capabilities. Unless a native text input (including elememts with enabled editing mode) is focused, shortcut keys for pasting will not trigger a paste event and the mouse's context menu will not offer an option for pasting. Recent versions of Chrome, Opera and Android Browser\footnote{\url{http://caniuse.com/\#feat=clipboard}, last checked on 07/22/2015} allow triggering arbitrary paste events thereby read the cliboard contents. With this, shortcuts could be enabled with JavaScript and instead of the native context menu, a customly build context menu using HTML could be shown that allows the user to paste, but this only works on elements in editing mode and only in these three browsers.

\subsection{Hidden native input fields} Apart from rich-text editors there are also third-party JavaScript libraries that allow embedding code editors with syntax highlighting in a website. The ''Ajax.org Cloud9 Editor (Ace)'' and ''CodeMirror'' editor are amongst the most well-known choices. Both editors keep an internal representation of the plain-text (i.e. non-highlighted) contents of the editor, parse it and display a highlighted version using HTML in a designated \texttt{div}. Both editors use a hidden \texttt{textarea} in which the user enters his or her input. The input will be read from the \texttt{textarea} and

% which is presented to the user as the input field.

\subsection{Caret}
caret
\subsection{BiDi support}
\subsection{IME} 
http://marijnhaverbeke.nl/blog/browser-input-reading.html 
https://en.wikipedia.org/wiki/Input\_method


\subsection{Selection}
Fake damit copy \& past nativ funktioniert
Obwohl eine selection mehrere Ranges haben kann, wird das von keinem Browser unterstützt http://stackoverflow.com/questions/4777860/highlight-select-multiple-divs-with-ranges-w-contenteditable/4780571\#4780571
Habe versucht mit die Darstellung über getClientRects zu emulierten, aber das ist buggy siehe https://github.com/edg2s/rangefix/blob/master/rangefix.js


\subsection{Selection Overlay}
overlay

\subsection{Formatting}
formatting
\subsection{Change Listener}
change
\subsection{Contents}
contents
\subsection{Development}
developmnent
\subsection{Dom Utilities}
dom util
\subsection{Dom Walker}

Working with text implies having to traverse the DOM, i.e. the nodes inside the text often. The {DomWalker} utility class solves this problem. The DOM API offers methods to access a node's siblings, children and parents, but it must always accounted for cases when any of these is \code{null} (there is no parent, sibling or child) or when they overflow the bounds of the editor's contents. But more importantly, for text editing, it is usually necessary to access the next (or previous) node in the document's content flow which can either be the parent, sibling or child. Also, it is often the case that it is not only necessary to fetch the next node, but to apply a filter to only fetch a specfic node, for instance a text node or only a text node that has contents visible to the user\footnote{Any text node consisting of whitespace only will not be displayed by any major browser}. Browsers offer a native API for this, called \code{TreeWalker}, but it is said to be slow\footnote{\url{http://jsperf.com/qsa-vs-node-iterator}}, is only partially supported by Internet Explorer 9\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator\#Browser_compatibility}} and has been critisized for its verbose API\footnote{By John Resig, author of jQuery\url{http://ejohn.org/blog/unimpressed-by-nodeiterator/}}.

\subsection{API}

The \code{DomWalker} class offers high-level methods for traversal, designed to quickly apply the most common filters. I can be instantiated with multiple shorthand parameters.

\begin{algorithm}
\caption{Simplified text formatting pseudocode}
\label{alg:format_pseudocode}
\begin{algorithmic}[1]
\State new DomWalker(startNode, node);
\State new DomWalker(startNode, 'filtername');
\State new DomWalker(startNode, filterFunction()\{\});
\State new DomWalker(startNode,\{optionsObject\});
\end{algorithmic}
\end{algorithm}

\noindent The API is not only designed for the development of this library but most importantly to be a utility too for developers extending the library or implementing editors.

%The API is designed for an easy and high-level usage to simplify the workflow for developing the library, but most importantly to offer a high-level and easy-to-use concept to other developers.

%dom walker. Used SO OFTEN in the project. Goal is to have a really simple api new DomWalker('text') by having lots of pre-defined magick in it.

\subsection{Environment}
env

\subsection{Core Api}

Api als eigenes Modul, separation of concerns, gute saubere code base und eigene saubere code base für die API. Laesst freiheiten in der Softwarearchitektur - lost coupling, API ein eigenes aenderbares gekapseltes modul:

\subsection{Event Api}
ev api

\subsection{Events}

Dazu entscheiden dass es ein Type-Internes Eventsystem gibt, dessen Events nur in Type existieren. Damit polluten die nicht den globalen (name)space mit events. Nur bestimmte events werden global (nativ) getriggert, und das sind genau die events, die nach aussenhin von Belang sind und abgegriffen werden koennen sollen (=API design)

\subsection{Input}
input event only event required so far

\subsection{Input Pipeline}
pipeline idea
rules for behaviours (lists, headlines, enter, spaces...)
Ursprünglich so gedacht: Was gehört zu einem editor X, Y und Behaviour. Für Behaviour aber das input pipeline system gefunden, welches das ganze schön abbildet/löst.
Noch mal skimmen und sehen ob da was dabei ist, besonders "Detour": http://marijnhaverbeke.nl/blog/browser-input-reading.html

\subsection{Pasting} Kontrolle durch die Implementierung mit einem versteckten Eingabefeld. Erst mal gibt es ein reliable Paste event, was es in keinem Editor basierend auf contentEditable gibt. 2. Hat man volle Kontrolle über den Inhalt, was gepastet wird und was nicht. Und das ganze mit einer einfachen API. Pasting sollte internes event ausloesen.


\subsection{Caret}
caret
\subsection{Command}
command
\subsection{Headlines}
head lines
\subsection{Line Breaks}
line breaks
\subsection{Lists}
lists
\subsection{Remove}
remove
\subsection{Spaces}
spaces

\subsection{Plugin Api}
plugin api
\subsection{Settings}
settings
\subsection{Text Walker}
text walker
\subsection{Utilities}
util

\subsection{Extensions}

\subsection{Plugin API} ...and plugin cache

\subsection{Many options for programmers}

\begin{lstlisting}[language=JavaScript, caption=Example calls to format text, label=lst:format-examples]
// Adding contructors
Type.fromEtherpad = function() { /* Implementation */ };

// Events to load plugins on instantiation
Type.on('ready', function(type) { /* Implementation */ });

// Lazy loading using plugin cache
Type.fn.myPluginMethod = function (tag, params) {
  var cmd = this.plugin('cmd', /* Plugin instantiation */ );
  /* Execute myPluginMethod */
};

// Static function calls just like jQuery
Type.fn.cmd = function (tag, params) { /* Implementation */ };
\end{lstlisting}

Erstellung von Erweiterungen und Plugins soll so einfach und frei wie möglich sein. Es ist die Verantwortung der Programmierer diese Freiheit so zu nutzen, dass sie trotzdem sauber arbeiten. jQuery zeigt, dass Freiheit funktioneren kann und nicht zu schlechtem nutzen führt. Schlechte Plugins sterben durch die Dynamik des ''Marktes'' aus. Die Vorteile ueberwiegen: Beim CKEditor ist es aufwändig (viel Code um sich in den Editor zu integrieren) und schwierig (Lernkurve) Erweiterungen zu schreiben. Der CKEditor ist aber auch ein Produkt und kein Framework. Ein Framework sollte Möglichkeiten geben und einfach (und painless) sein. jQuery hat für sich Konventionen erzeugt und Möglichkeiten gegen, die Programmierer effektiv arbeiten lassen können. Und jQuery zeigt: Es funktioniert.

\subsection{Etherpad} Collaboration with etherpad ist wirklich einfach zu machen mit meinem coolen editor. Mein Editor ist ganz ganz toll dass das so einfach geht, ja!
Markdown wohl eher als Ausblick.
