%!TEX root = ../../thesis.tex

\section{Disadvantages of HTML Editing APIs}
\label{sec:disadvantages_of_html_editing_apis}
\subsection{No specification on the generated output}

The specifications on the HTML editing APIs do not state what markup should be generated by specific commands. There are vast differences in the implememtations of all major browsers. Calling the \texttt{italic} command Internet Explorer, Firefox and Chrome all generate different markup.

\begin{lstlisting}[language=html, caption=Markup of italic command in Internet Explorer, label=lst:italic-ie]
<i>Lorem ipsum</i>
\end{lstlisting}

\begin{lstlisting}[language=html, caption=Markup of italic command in Firefox, label=lst:italic-firefox]
<span style="font-style: italic;">Lorem ipsum</span>
\end{lstlisting}

\begin{lstlisting}[language=html, caption=Markup of italic command in Chrome, label=lst:italic-chrome]
<em>Lorem ipsum</em>
\end{lstlisting}

\noindent This is a \textit{major} problem for web development, because it makes processing input very difficult. For a content management system or a blogging platform it can be very hard to handle the input of users only because different browsers are being used. Given the number of possible edge cases, it is very hard to normalize the input.

Apart from that Internet Explorer's output is semantically incorrect for most use cases\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i\#Notes}, last checked on 07/17/2015} while Firefox's output is breaking sementics entirely and is considered a bad style in terms of the separation of concerns of HTML and CSS\footnote{\url{https://en.wikipedia.org/wiki/Separation\_of\_concerns\#HTML.2C\_CSS.2C\_JavaScript}, last checked on 07/17/2015}.

Different browsers will not only generate different markup when executing commands. When a user enters a line break (by pressing enter), Firefox will insert a \texttt{<br>} tag, Chrome and Safari will insert a \texttt{<div>} tag and Internet Explorer will insert a \texttt{<p>} tag. Most features of the HTML editing APIs that generate markup show different implementations across different browsers.


\subsection{Flawed API} 
\label{subsec:flawed_api}

The original and mostly unaltered API is limited and not very effective. MDN lists 44 commands available for their \texttt{execCommand} implementation\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/document/execCommand\#Commands}, last checked on 07/17/2015}. While other browsers do not match these commands exactly, their command lists are mostly similar. 23 of these commands format the text (for instance to italicize or make text bold) by wrapping the current selection with tags like \texttt{<em>} or \texttt{<strong>}. The only difference between any of these commands is which tag will be used. At the same time there is no command to wrap the selected text in an arbitrary tag, for instance to apply a custom class to it (\texttt{<span class="highlight">Lorem ipsum</span>}). All 23 commands could be summarized by a single command that allows to pass custom tags or markup that the selected text will be wrapped with it. This applies to inserting elements as well. 7 commands insert different kinds of HTML elements, this could be simplified and extended by allowing to insert any kind of (valid) markup with a single command. 

% This would not only simplify the API, but would also give it enormously more possibilities.

Both alternatives would also give developers more control of what to insert. As previously described, browsers handle formatting differently. Allowing to format with specific HTML would generate consistent markup (in the scope of a website) and would allow developers generate the markup that fits their needs.


\subsection{Restrictions}

Google points out that implementing an editor using HTML editing APIs comes with the restriction that such an editor can only offer the least common denominator of functions supported by all browsers. They argue, if one browser does not support a specific feature or its implementation is buggy, it cannot be supported by the editor\footnote{\url{http://googledrive.blogspot.fr/2010/05/whats-different-about-new-google-docs.html}, last checked on 07/18/2015}. This is mostly true, although it is to be noted, that editors like CKEditor show, that some bugs can be worked around as well as some functionality be added through JavaScript. These workarounds still have limitations and not everything can be fixed. In particular there can be cases where the editing mode is not able to handle content inserted or altered by workarounds, thus limiting the features of an editor. Google names layouting the editor's  contents with tab stops as one example.

\subsection{Clipboard}
\label{subsec:editing_disadvantages_clipboard}

When dealing with user input, usually some sort of filtering is required. It is possibly harmful to accept any kind of input. This must be checked on the server side since attackers can send any data, regardless of the front end a system offers. However, in a cleanly designed system, the designated front end should not accept and send ''bad'' data to the back end. This applies to harmful content as well as to content that is simply \textit{unwanted}. For example, for asthetical reasons, a comment form can be designed to allow bold and italic font formatting, but not headlines or colored text.

Implementing a rich-text editor with HTML editing APIs, unwanted formatting can be prevented simply by not offering input controls for these formattings (assuming no malicious behavior by the user). However contents can be pasted from the clipboard that contain any kind of formatting into elements in editing mode. HTML editing APIs provide no way to define or apply filtering to the formattings of pasted contents.

Recent versions of major browsers allow observing paste events. Chrome, Safari, Firefox and Opera grant full read access to the clipboard contents from paste events. In these browsers, the event can be stopped and its contents can be processed. Internet Explorer grants access to plain-text and URL contents only. Android Browser, Chrome for Android and IOS Safari allow reading the clipboard contents on paste events as well. Other browsers and some older versions of desktop and mobile browsers do not support clipboard access or listening to paste events. Overall, 82.78\% of internet users support listening to and reading from clipboard events\footnote{\url{http://caniuse.com/\#feat=clipboard}, last checked on 07/18/2015}.

When dealing with the clipboard, especially older browsers show an unexpected behavior. Older WebKit-based browsers insert so-called ''Apple style spans''\footnote{\url{https://www.webkit.org/blog/1737/apple-style-span-is-gone/}, last checked on 07/18/2015} on copy and paste commands. ''Apple style spans'' are pieces of markup that have no visible representation, but clutter up the underlying contents of an editor. When pasting formatted text from Microsoft Word, Internet Explorer inserts underlying XML, that Word uses to control its document flow, into the contents of the editor.


\subsection{Bugs} 

HTML editing APIs are prone to numerous bugs. Especially older browser versions are problematic. Piotrek Koszuli\'{n}ski states:

%\begin{quotation}
%\textit{''First of all... Don't try to make your own WYSIWYG editor if you're thinking about commercial use. [...] I've seen recently some really cool looking new editors, but they really doesn't[sic] work. Really. And that's not because their developers suck - it's because browsers suck.''}\footnote{\url{http://stackoverflow.com/questions/10162540/contenteditable-div-vs-iframe-in-making-a-rich-text-wysiwyg-editor/11479435\#11479435}, last checked on 07/18/2015}
%\end{quotation}

\begin{quotation}
\textit{''Don't write wysiwyg editor[sic] - use one that exists. It's going to consume all your time and still your editor will be buggy. We [...] are working on this for years and we still have full bugs lists\cite{sopp}''}
\end{quotation} %\footnote{\url{http://stackoverflow.com/questions/11240602/paste-as-plain-text-contenteditable-div-textarea-word-excel/11290082#11290082}, last checked on 07/13/2015}


\noindent Mozilla lists 1060 active issues related to its ''Editor'' component\cite{bi}. Google lists 420 active issues related to ''Cr-Blink-Editing''\cite{bh}. The WebKit project lists 641 active issues related to ''HTML Editing''\cite{bg}. Microsoft and Opera Software allow public access to their bug trackers. As quoted above, some rich-text editors like CKEditor have been developed for over 10 years and still need to fix bugs related to the editing API\cite{bf}\cite{so_paste_plain}. Some bugs have caused big websites to block particular browsers entirely\cite{medium_blocked}. %Medium however has contacted Microsoft and lead them to fix this bug.

%\footnote{\url{https://bugzilla.mozilla.org/buglist.cgi?bug\_status=\_\_open\_\_\&component=Editor\&product=Core\&query\_format=advanced\&order=bug\_status\%2Cpriority\%2Cassigned\_to\%2Cbug\_id\&limit=0}, last checked on 07/18/2015}
%\footnote{\url{https://code.google.com/p/chromium/issues/list?q=label:Cr-Blink-Editing}, last checked on 07/18/2015}
%\footnote{\url{https://bugs.webkit.org/buglist.cgi?query\_format=advanced\&bug\_status=UNCONFIRMED\&bug\_status=NEW\&bug\_status=ASSIGNED\&bug\_status=REOPENED\&component=HTML\%20Editing}, last checked on 07/18/2015}
%\footnote{\url{http://dev.ckeditor.com/report/2}, last checked on 07/18/2015}
%\footnote{\url{http://stackoverflow.com/questions/11240602/paste-as-plain-text-contenteditable-div-textarea-word-excel/11290082#11290082}, last checked on 07/18/2015}
% \footnote{\url{https://medium.com/medium-eng/the-bug-that-blocked-the-browser-e28b64a3c0cc}, last checked on 07/18/2015}
%
%

Given the argument that editing APIs provide easy to use and high-level methods to format text, in practice, the number of bugs and workarounds required, renders a ''quick and easy'' implementation impossible. Most importantly, browser bugs cannot be fixed by web developers. At best they can be worked around, enforcing particular software design on developers, possibly spawning more bugs and making the development dependent of the development of browsers and user adoption.