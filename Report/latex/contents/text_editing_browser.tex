%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Text editing in browser environments}

% \section{Differing technical requirements in browser environments}
% Browser environment differs from desktop environments. 
% Memory management, garbage collection, none of that is necessary
% The basis for web projects is the DOM and the data and procedures written in JavaScript
% Hacks are normal

\section{Plain-text inputs}

Text input components for browsers have been introduced with the specification of HTML 2.0\footnote{\url{https://tools.ietf.org/html/rfc1866}, last checked on 07/15/2015}. The components proposed include inputs for single line (written as \texttt{<input type=''text'' />}) and multiline texts (written as \texttt{<textarea></textarea>}). These inputs allow writing plain-text only.


\section{Rich-text editing}

Major browsers, i.e. any browser with a market share above 0.5\%\footnote{\url{http://gs.statcounter.com/#all-browser-ww-monthly-201406-201506-bar}, last checked on 07/15/2015}, do not offer native input fields that allow rich-text editing. Neither the W3C's HTML5 and HTML5.1 specifications nor the WHATWG HTML specification recommend such elements. However, by being able to display HTML, browsers effectively are rich-text viewers. By the early 2000s, the first JavaScript libraries emerged, that allowed users to interactively change (parts of) the HTML of a website, to enable rich-text editing in the browser. The techniques used will be discussed in section~\ref{sec:html-editing-apis} through section~\ref{sec:useage-of-html-editing-apis}.

\subsection{HTML Editing APIs}
\label{sec:html-editing-apis}

In July 2000, with the release of Internet Explorer 5.5, Microsoft introduced the IDL attributes \texttt{contentEditable} and \texttt{designMode} along with the content attribute \texttt{contenteditable}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533720(v=vs.85).aspx}, last checked on 07/10/2015}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}. These attributes were not part of the W3C's HTML 4.01 specifications\footnote{\url{http://www.w3.org/TR/html401/}, last checked on 07/14/2015} or the ISO/IEC 15445:2000\footnote{\url{http://www.iso.org/iso/iso\_catalogue/catalogue\_tc/catalogue\_detail.htm?csnumber=27688}, last checked on 07/14/2015}, the defining standards of that time. Table \ref{table:editing-api-attributes} lists these attributes and possible values.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{llll}
\hline
Attribute       & Type              & Can be set to         & Possible values                     \\ \hline
designMode      & IDL attribute     & Document              & "on", "off"                         \\
contentEditable & IDL attribute     & Specific HTMLElements & boolean, "true", "false", "inherit" \\
contenteditable & content attribute & Specific HTMLElements & empty string, "true", "false"       \\ \hline
\end{tabular}
}
\caption{Editing API attributes}
\label{table:editing-api-attributes}
\end{table}

\begin{lstlisting}[language=html, caption=An element set to editing mode, label=lst:div-contenteditable]
<div contenteditable="true">
  This text can be edited by the user.
</div>
\end{lstlisting}

By setting \texttt{contenteditable} or \texttt{contentEditable} to ''true'' or \texttt{designMode} to ''on'', Internet Explorer 5.5 switches the affected elements and their children to an editing mode. The \texttt{designMode} can only be applied to the entire document and the \texttt{contentEditable} and \texttt{contenteditable} attributes can be applied to specific HTML elements as described on Microsoft's Developer Network (MSDN) online documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}. These elements include ''divs'', ''paragraphs'' and the docuement's ''body'' element amongst others. In editing mode

\begin{enumerate} \item Users can interactively click on and type inside texts \item An API is enabled that can be accessed via JScript and JavaScript\end{enumerate}

Setting the caret by clicking on elements, accepting keyboard input and modifying text nodes is handled entirely by the browser. No further scripting is necessary.

The API enabled can be called globally on the \texttt{document} object, but will only execute when the user's selection or caret is focussed inside an element in editing mode. Table \ref{table:editing-mode-api} lists the full HTML editing API. To format text, the method \texttt{document.execCommand} can be used. Calling

\begin{lstlisting}[language=JavaScript, caption=Emphasizing text using the HTML editing API, label=lst:execcommand-italics]
document.execCommand('italic', false, null);
\end{lstlisting}

\noindent will wrap the currently selected text inside an element in editing mode with \texttt{<i>} tags. The method accepts three parameters. The first paramter is the ''Command Identifier'', that determines which command to execute. For instance, this can be \texttt{italic} to italicize the current selection or \texttt{createLink} to create a link with the currently selected text as label.

\begin{lstlisting}[language=JavaScript, caption=Creating a link using the HTML editing API, label=lst:execcommand-link]
document.execCommand('createLink', false, 'http://google.de/');
\end{lstlisting}

The \textit{third} parameter will be passed on to the internal command given as first parameter. In the case of a \texttt{createLink} command, the third parameter is the URL to be used for the link to create. The \textit{second} paramter determines if executing a command should display a user interface specific to the command. For instance, using the \texttt{createLink} command with the second parameter set to \texttt{true} and not passing a third parameter, the user will be prompted with a system dialog to enter a URL. A full list of possible command identifiers can be found on MSDN\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533049(v=vs.85).aspx}, last checked on 07/10/2015}.

\subsection{Development of HTML Editing APIs}

With the release of Internet Explorer 5.5 and the introduction of editing capabilities, Microsoft released a short documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}, containing the attributes' possible values and element restrictions along with two code examples. Although a clear purpose has not been stated, the code examples demonstrated how to implement rich-text input fields with it. Mark Pilgrim, author of the ''Dive into'' book series and contributor to the the Web Hypertext Application Technology Working Group (WHATWG), also states that the API's first use case has been for rich-text editing\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/10/2015}. 

%% With the release of Internet Explorer 5.5 and the introduction of editing capabilities, Microsoft released a sparse documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015} describing only the availability and the before-mentioned element restrictions of these attributes. 

%% According to Mark Pilgrim, author of the ''Dive into'' book series and contributor to the the Web Hypertext Application Technology Working Group (WHATWG),, but its first use case has been for rich-text editing\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/10/2015}. 

% It is notable, that the available command identifiers mostly include text-editing (or related) commands, but not exclusively. Other commands include navigating to other URLs or controlling the browser's cache.

In March 2003, the Mozilla Foundation introduced an implementation of Microsoft's designMode, named Midas, for their release of Mozilla 1.3. Mozilla already named this ''rich-text editing support'' on the Mozilla Developer Network (MDN)\footnote{\url{https://developer.mozilla.org/en/docs/Rich-Text\_Editing\_in\_Mozilla}, last checked on 07/10/2015}. In June 2008, Mozilla added support for contentEditable IDL and contenteditable content attributes with Firefox 3. 

Mozilla's editing API mostly resembles the API implemented for Internet Explorer, however, to this present day, there are still differences (compare\footnote{\url{https://msdn.microsoft.com/en-us/library/hh772123(v=vs.85).aspx}, last checked on 07/10/2015}\footnote{\url{https://developer.mozilla.org/en-US/docs/Midas}, last checked on 07/10/2015}). This includes the available command identifiers \footnote{\url{https://developer.mozilla.org/en-US/docs/Midas}, last checked on 07/10/2015}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533049(v=vs.85).aspx}, last checked on 07/10/2015} as well as the markup generated by invoking commands\footnote{\url{https://developer.mozilla.org/en/docs/Rich-Text\_Editing\_in\_Mozilla#Internet\_Explorer\_Differences}, last checked on 07/10/2015}. 

%% Mozilla's command identifiers are restricted to text-editing command, showing the clear purpose of this API.

%% This may show, that even though rich-text editing was its first use case and Mozilla implemented it naming it that, this editing API was not originally intended to be used as such.

In June 2006, Opera Software releases Opera 9\footnote{\url{http://www.opera.com/docs/changelogs/windows/}, last checked on 07/10/2015}, providing full support for contentEditable and designMode\footnote{\url{http://www.opera.com/docs/changelogs/windows/900/}, last checked on 07/10/2015}, followed by Apple in March 2008\footnote{\url{https://www.apple.com/pr/library/2008/03/18Apple-Releases-Safari-3-1.html}, last checked on 07/10/2015} providing full support Safari 3.1\footnote{\url{http://caniuse.com/#feat=contenteditable}, last checked on 07/10/2015}. MDN lists full support in Google Chrome since version 4\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content\_Editable}, last checked on 07/10/2015}, released in January 2010\footnote{\url{http://googlechromereleases.blogspot.de/2010/01/stable-channel-update\_25.html}, last checked on 07/10/2015}.

%In March 2008, Apple released Safari 3.1\footnote{\url{https://www.apple.com/pr/library/2008/03/18Apple-Releases-Safari-3-1.html}, last checked on 07/10/2015} including full support for contentEditable and designMode\footnote{\url{http://caniuse.com/#feat=contenteditable}, last checked on 07/10/2015}, followed by Opera Software in June 2006\footnote{\url{http://www.opera.com/docs/changelogs/windows/}, last checked on 07/10/2015} providing full support in Opera 9\footnote{\url{http://www.opera.com/docs/changelogs/windows/900/}, last checked on 07/10/2015}. MDN lists full support in Google Chrome since version 4\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content\_Editable}, last checked on 07/10/2015}, released in January 2010\footnote{\url{http://googlechromereleases.blogspot.de/2010/01/stable-channel-update\_25.html}, last checked on 07/10/2015}.

Starting in November 2004, WHATWG members have started actively discussing to incorporate these editing APIs in the HTML5 standard. Through reverse engineering, the WHATWG developed a specification based on Microsoft's implementation\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/15/2015} and finally decided to include it in HTML5. With W3C's coorporation and the split in 2011, similar editing APIs based on this work are now included in W3C's HTML5 Standard\footnote{\url{http://www.w3.org/TR/html5/editing.html}, last checked on 07/15/2015} and WHATWG's HTML Standard\footnote{\url{https://html.spec.whatwg.org/multipage/interaction.html#editing-2}, last checked on 07/15/2015}.

\subsection{Emergence of HTML editing JavaScript libraries}

Around the year 2003\footnote{compare \textit{Meine Tabelle aller Editoren}} the first JavaScript libraries emerged that made use of Microsoft's and Mozilla's editing mode to offer rich-text editing in the browser. Usually these libraries were released as user interface components (text fields) with inherent rich-text functionality and were only partly customizable.

In May 2003 and March 2004 versions 1.0 of ''FCKEditor''\footnote{Now distributed as ''CKEditor''} and ''TinyMCE'' have been released as open source projects. These projects are still being maintained and remain among the most used rich-text editors. TinyMCE is the default editor for Wordpress and CKEditor is listed as the most popular rich-text editor for Drupal\footnote{\url{https://www.drupal.org/project/project\_module}, last checked on 07/16/2015}. 

Since the introduction of Microsoft's HTML editing APIs, a large number of rich-text editors have been implemented. While many have been abandoned, GitHub lists about 600 JavaScript projects related to rich-text editing\footnote{\url{https://github.com/search?o=desc\&q=wysiwyg\&s=stars\&type=Repositories\&utf8=\%E2\%9C\%93}, last checked on 07/16/2015}. However, it should be noted, that some projects only use other projects' editors and some projects are stubs. Popular choices on GitHub include ''MediumEditor'', ''wysihtml'', ''Summernote'' and others.


\subsection{Usage of HTML Editing APIs}
\label{sec:useage-of-html-editing-apis}

Most rich-text editors use HTLM editing APIs as their basis. CKEditor and TinyMCE dynamically create an \texttt{iframe} on instantiation and set its \texttt{body} to editing mode using \texttt{contenteditable}. Doing so, users can type inside the \texttt{iframe} so it effectively acts as text input field. Both libraries wrap the \texttt{iframe} in a user interface with buttons to format the \texttt{iframe}'s contents. When a user clicks on a button in the interface \texttt{document.execCommand} will be called on the \texttt{iframe}'s \texttt{document} and the selected text will be formatted. While using an \texttt{iframe} is still in practice, many newer editors use a  \texttt{div} instead. The advantages and disadvatanges of this technique will be discussed in Sections XY.

\subsection{Standardization of HTML Editing APIs}
\label{sec:standardization-of-html-editing-apis}

It makes sense to use HTML editing APIs for rich-text editing. Microsoft's demos published with the release of these API suggest to do so. Mozilla picked up on it and called their implementation ''rich-text editing API''. Other browsers followed with APIs based on Microsoft's idea of editable elements. However, it would have been imaginable for browsers to offer a native user interface component, a dedicated rich-text input field.

The HTML editing APIs have only been standardized with HTML5, which itself introduces 13 new types of input fields\footnote{\url{https://developer.mozilla.org/en/docs/Web/HTML/Element/Input}, last checked on 07/16/2015}, but none with rich-text capabilites. The WHATWG discussed various ways to specify rich-text editing for the upcoming HTML5 standard, including dedicated input fields. The issues that have been faced with that idea are 

\begin{enumerate} 
\item Finding a way to tell the browser which language the rich-text input should generate. E.g. should it output (the then popular) ''bb'' code, (X)HTML, Textile or something else?
\item How can browser support for a rich-text input be achieved?
\end{enumerate}

%% Den browser support teil kann ich später gut aufgreifen, damit dass meine library immer 100% browser support hat

Ian Hickson, editor of WHATWG and author of the HTML5 specification adresses these main issues in a message from November 2004\footnote{\url{https://lists.w3.org/Archives/Public/public-whatwg-archive/2004Nov/0014.html}, last checked on 07/16/2015}. He states

\begin{quotation}
\textit{Realistically, I just can't see something of this scoped[sic] [the ability to specify a input 'language' for a text-area and possibly to specify a subset of language elements allowed] getting implemented and shipped in the default install of browsers.}
\end{quotation}

and agrees with Ryan Johnson, who states

\begin{quotation}
\textit{Anyway, I think that it might be quite a jump for manufacturers. I also see that a standard language would need to be decided upon just to describe the structure of the programming languages. Is it worth the time to come up with suggestions and examples of a programming language definition markup, or is my head in the clouds?}
\end{quotation}

Ian Hickson finally concludes

\begin{quotation}
\textit{Having considered all the suggestions, the only thing I could really see 
as being realistic would be to do something similar to (and ideally 
compatible with) IE's "contentEditable" and "designMode" attributes.}
\end{quotation}

Mark Pilgrim lists this as milestone of the decision to integrate Microsoft's HTML editing APIs in the HTML5 standard.\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/16/2015}.

% By understanding the origins, the development and the process of standardization, it can be seen that the incorporation of the HTML editing APIs as designed by Microsoft has not been decided because they are a \textit{good idea}, but to be compatible with other systems and ultimately Internet Explorer 5.5.

\subsection{HTML Editing APIs are questionable}

Understanding the history of the HTML editing APIs, the reasons for their wide browser support and their final standardization are questionable. It can be doubted if they fit their purpose secifically well. In fact, all major browsers simply mimicked the API as implemented in Internet Explorer 5.5. The reasons for this have not been publically discussed. A reason may have been to be able to compete with the other browsers in terms of features. Both, Microsoft's original implementation as well as Mozilla's adoption have been released in the main years of the so-called ''browser wars''. However, applying prectically no change to the API, it can be argued that compatibility, being able to display websites implemented for Internet Explorer, may have been a central factor for Mozilla. Other now popular browsers, i.e. Chrome, Safari and Opera, implemented these APIs only years later, when JavaScript libraries based on them have already been popular and widely used, which could have been an influence on these decisions. It has clearly been stated (see section \ref{sec:standardization-of-html-editing-apis}), that the reason for standardizing these APIs have mostly been to ensure browser support.

The API itself stems from the time when the usage of the web was different from today, its future was still unknown and web applications like Google Docs have not even been thought of. It should be discussed if this API really is the answer to all problem and if it still fits (or ever fit) modern requirements for content management systems or web application. The advantantages, disadvantages and practical issues will be discussed in sections x y z.


% but because they were \textit{already there} and could used on most PCs.% by the majority of users.

%% From its history it's clear to see that the HTML editing APIs just came to be by adoption of browser manufacturer's and ultimately have been standardized for the main reason because they have already been there.


% Using an iFrame as input field has been popular for years and many other rich-text editors have worked this way. The reasons for this have been described by Tim Down, author of the popular Rangy library and Piotrek Koszuliński, core developer of CKEditor\footnote{\url{http://stackoverflow.com/a/4430583/1183252}, last checked on 07/16/2015}\footnote{\url{http://stackoverflow.com/a/11222149/1183252}, last checked on 07/16/2015}:

% \begin{enumerate} \item Styling is encapsulated in the \texttt{iframe} and does not affect the document outside the editor. \item Historically, browsers had buggy implementations of the \texttt{contenteditable}, so it was not possible to only make specific elements on a page editable and act as input field. \end{enumerate}

% Even today many editors still use this technique, but it has severe downsides and the pro arguments are obsolete. This will be discussed in Sections XY.

%% How Js Libraries work. Maybe how only a few work. StackOverlfow quote, buglists, Medium post, other stuff to find.

%% Seeing how editing APIs have come to existance, as an undocumented API by microsoft, taken over by mozilla, bossted by JS libraries and then adopted by other browsers, it can be understood how editing APIs came to be. However, by its introduction by microsoft, it has not been stated that this has been its original purpose. And even if Mozilla picked up on it, it is not clear that this API is in fact the best way to implement rich-text editing. WHATWG has discussed this API, arguing if it is the best way to provide rich-text functionality.

%% ** WICHTIG DEN BOGEN ZU SPANNEN WARUM ICH ÜBER DIE GESCHICHTE SCHREIBE** ERKLÄREN, DASS ALLE DIE API VON MICROSOFT ÜBERNOMMEN HABEN; ANSTATT RICH-TEXT ELEMENTE EINZUFÜHREN. HTML5 HAT KOMPONENTEN FÜR TIME UND DATE; WARUM NICHT RICH TEXT- WHATWG HAT DAS DISCUSSED. WAS WAREN DIE GRÜNDE?. BEI DER BESCHREIBUNG DARAUF ACHTEN DASS ICH DEN GRUND GEBE; WARUM ICH DIE ENTWICKLUNG SO LANGE ERKLÄRE. VIELLEICHT AUCH SAGEN, DASS TROTZ DASS HTML5 ERST SEIT X RELEASED WURDE, ANHAND DER GESCHICHTE GESEHEN WERDEN KANN; DASS ES SCHON LANGE BROWSER SUPPORT GIBT.

%% Seeing the history of editing APIs, it is understandable how this has become the standard for rich-text editing. However, with its introduction in Internet Explorer 5.5, it has not been stated that the \texttt{designMode} end \texttt{contentEditable} attributes have been intended to enable rich-text editing. Sections X and Y will discuss the advantages and disadvantages of these APIs.

% Rich-text editing in browsers is only possible though JavaScript. Essentially, libraries enabling rich-text editing display a nested webpage through an iFrame and let the user modify its contents to emulate a rich-text input. Commonly, modification is realized though the browser's so-called ''HTML Editing APIs'', which will be discussed in Section XXX (HTML Editing APIs).

\subsection{Advantages of HTML Editing APIs}

HTML Editing APIs have some notable advantages which will be discussed in this section.

\paragraph{Browser support}

A fair reason for using HTML editing APIs is its wide browser support. caniuse.com lists browser support for 92.78\% of all used web browsers\footnote{\url{http://caniuse.com/#search=contenteditable}, last checked on 07/17/2015}. I.e. 92.78\% of all people using the web use browsers that have full support for HTML editing APIs.

\paragraph{High-level API}

HTML editing APIs offer high-level commands for formatting text. It requires little setup to implement basic rich-text editing. The browser takes care of generating the required markup.

\paragraph{HTML output}

HTML editing APIs modify and generate HTML. In the context of web development, user input in this format is likely to be useful for further processing.

\paragraph{No need for language definitions}

The WHATWG discussed dedicated rich-text inputs, for instance as an extension of the \texttt{textarea} component. Offering a native input for general rich-text input brings up the question which use-cases this input conforms. For a forum software, it might be useful to generate ''BB'' code, while for other purposes other languages might be needed. Offering HTML editing APIs offers a semantically distinct solution, while still enabling a way to implement rich-text editing. %  Conforming the way HTML forms work, offering a native rich-text input, should send the native code that it generates to the server without further processing. That's why it would suck if it sent HTML for BB code editing.

\paragraph{Possbile third-party solutions for other languages}

While HTML editing APIs can be used to generate HTML only, third-party libraries can build on top of that by implementing editors that write ''BB'' code (for instance) and use HTML only for displaying it as rich-text.

\subsection{Disadvantages of HTML Editing APIs}

lack of control
bugs
it seems to me the api as provided is a bad idea. Programmers can handle control, and why not make this control specific instead of executing bulkish commands.
very limited api. limited wo a few commands and a few paramters
No specifications on what markup to generate (mozilla != ie, mdn has links for that)
\paragraph{pasting}
is a problem: shitty markup can be pasted, paste event not implemented in all browser, some offer a modal, some clean up after change. I can solve this problem.

\subsection{DOM manipulation without Editing APIs}

In October 1998 the World Wide Web Consortium (W3C) published the ''Document Object Model (DOM) Level 1 Specification''. This specification includes an API on how to alter DOM nodes and the document's tree\footnote{\url{http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html}, last checked on 07/10/2015}. It provided a standardized way for changing a website's contents. With the implementations of Netscape's JavaScript and Microsoft's JScript this API has been made accessible to web developers.

\subsection{Advantages of rich-text editing without Editing APIs}

Only this can guarantee the same behaviour and the same output across all browsers.
It puts the contenteditable implementation in the hand of JavaScript developers. We no longer have to wait for browsers to fix issues *and conform each other* and thus can be faster, at least possibly, than browsers are.
Also we can deploy updates immediately to all users and do not have to worry they use old browsers even if updates exist.

\subsection{Disadvantages of rich-text editing without Editing APIs}

Apparently implementing editing is prone to a lot of bugs issues **and edge-casese**. It can be assumed that it is difficult to do so. / Discuss the issues discussed by WHATWG here. It's difficult to do this.

Also this can be seen as ''yet another'' implementation of contenteditable, equal to browser implementations. Just one more editor for developers to take care of. However, this isn't quite correct, cos developers usually can choose a single editor that is used for the entire project, so they only have to take care of a single editor.

\subsection{Disadvantages of offering user interface components}

Warum es besser ist eine library zu shippen und nicht einen editor als ui component

