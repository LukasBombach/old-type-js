%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Text editing in browser environments}

% \section{Differing technical requirements in browser environments}
% Browser environment differs from desktop environments. 
% Memory management, garbage collection, none of that is necessary
% The basis for web projects is the DOM and the data and procedures written in JavaScript
% Hacks are normal

\section{Plain-text inputs}

Text input components for browsers have been introduced with the specification of HTML 2.0\footnote{\url{https://tools.ietf.org/html/rfc1866}, last checked on 07/15/2015}. The components proposed include inputs for single line (written as \texttt{<input type=''text'' />}) and multiline texts (written as \texttt{<textarea></textarea>}). These inputs allow writing plain-text only.


\section{Rich-text editing}

Major browsers, i.e. any browser with a market share above 0.5\%\footnote{\url{http://gs.statcounter.com/#all-browser-ww-monthly-201406-201506-bar}, last checked on 07/15/2015}, do not offer native input fields that allow rich-text editing. Neither the W3C's HTML5 and HTML5.1 specifications nor the WHATWG HTML specification recommend such elements. However, by being able to display HTML, browsers effectively are rich-text viewers. By the early 2000s, the first JavaScript libraries emerged, that allowed users to interactively change (parts of) the HTML of a website, to enable rich-text editing in the browser. The techniques used will be discussed in section~\ref{sec:html-editing-apis} through section~\ref{sec:useage-of-html-editing-apis}.

\subsection{HTML Editing APIs}
\label{sec:html-editing-apis}

In July 2000, with the release of Internet Explorer 5.5, Microsoft introduced the IDL attributes \texttt{contentEditable} and \texttt{designMode} along with the content attribute \texttt{contenteditable}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533720(v=vs.85).aspx}, last checked on 07/10/2015}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}. These attributes were not part of the W3C's HTML 4.01 specifications\footnote{\url{http://www.w3.org/TR/html401/}, last checked on 07/14/2015} or the ISO/IEC 15445:2000\footnote{\url{http://www.iso.org/iso/iso\_catalogue/catalogue\_tc/catalogue\_detail.htm?csnumber=27688}, last checked on 07/14/2015}, the defining standards of that time. Table \ref{table:editing-api-attributes} lists these attributes and possible values.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{llll}
\hline
Attribute       & Type              & Can be set to         & Possible values                     \\ \hline
designMode      & IDL attribute     & Document              & "on", "off"                         \\
contentEditable & IDL attribute     & Specific HTMLElements & boolean, "true", "false", "inherit" \\
contenteditable & content attribute & Specific HTMLElements & empty string, "true", "false"       \\ \hline
\end{tabular}
}
\caption{Editing API attributes}
\label{table:editing-api-attributes}
\end{table}

\begin{lstlisting}[language=html, caption=An element set to editing mode, label=lst:div-contenteditable]
<div contenteditable="true">
  This text can be edited by the user.
</div>
\end{lstlisting}

By setting \texttt{contenteditable} or \texttt{contentEditable} to ''true'' or \texttt{designMode} to ''on'', Internet Explorer 5.5 switches the affected elements and their children to an editing mode. The \texttt{designMode} can only be applied to the entire document and the \texttt{contentEditable} and \texttt{contenteditable} attributes can be applied to specific HTML elements as described on Microsoft's Developer Network (MSDN) online documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}. These elements include ''divs'', ''paragraphs'' and the docuement's ''body'' element amongst others. In editing mode

\begin{enumerate} \item Users can interactively click on and type inside texts \item An API is enabled that can be accessed via JScript and JavaScript\end{enumerate}

Setting the caret by clicking on elements, accepting keyboard input and modifying text nodes is handled entirely by the browser. No further scripting is necessary.

The API enabled can be called globally on the \texttt{document} object, but will only execute when the user's selection or caret is focussed inside an element in editing mode. Table \ref{table:editing-mode-api} lists the full HTML editing API. To format text, the method \texttt{document.execCommand} can be used. Calling

\begin{lstlisting}[language=JavaScript, caption=Emphasizing text using the HTML editing API, label=lst:execcommand-italics]
document.execCommand('italic', false, null);
\end{lstlisting}

\noindent will wrap the currently selected text inside an element in editing mode with \texttt{<i>} tags. The method accepts three parameters. The first paramter is the ''Command Identifier'', that determines which command to execute. For instance, this can be \texttt{italic} to italicize the current selection or \texttt{createLink} to create a link with the currently selected text as label.

\begin{lstlisting}[language=JavaScript, caption=Creating a link using the HTML editing API, label=lst:execcommand-link]
document.execCommand('createLink', false, 'http://google.de/');
\end{lstlisting}

The \textit{third} parameter will be passed on to the internal command given as first parameter. In the case of a \texttt{createLink} command, the third parameter is the URL to be used for the link to create. The \textit{second} paramter determines if executing a command should display a user interface specific to the command. For instance, using the \texttt{createLink} command with the second parameter set to \texttt{true} and not passing a third parameter, the user will be prompted with a system dialog to enter a URL. A full list of possible command identifiers can be found on MSDN\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533049(v=vs.85).aspx}, last checked on 07/10/2015}.

\subsection{Development and standardization of HTML Editing APIs}

With the release of Internet Explorer 5.5 and the introduction of editing capabilities, Microsoft released a short documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015}, containing the attributes' possible values and element restrictions along with two code examples. Although a clear purpose has not been stated, the code examples demonstrated how to implement rich-text input fields with it. Mark Pilgrim, author of the ''Dive into'' book series and contributor to the the Web Hypertext Application Technology Working Group (WHATWG), also states that the API's first use case has been for rich-text editing\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/10/2015}. 

%% With the release of Internet Explorer 5.5 and the introduction of editing capabilities, Microsoft released a sparse documentation\footnote{\url{https://msdn.microsoft.com/en-us/library/ms537837(VS.85).aspx}, last checked on 07/10/2015} describing only the availability and the before-mentioned element restrictions of these attributes. 

%% According to Mark Pilgrim, author of the ''Dive into'' book series and contributor to the the Web Hypertext Application Technology Working Group (WHATWG),, but its first use case has been for rich-text editing\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/10/2015}. 

% It is notable, that the available command identifiers mostly include text-editing (or related) commands, but not exclusively. Other commands include navigating to other URLs or controlling the browser's cache.

In March 2003, the Mozilla Foundation introduced an implementation of Microsoft's designMode, named Midas, for their release of Mozilla 1.3. Mozilla already named this ''rich-text editing support'' on the Mozilla Developer Network (MDN)\footnote{\url{https://developer.mozilla.org/en/docs/Rich-Text\_Editing\_in\_Mozilla}, last checked on 07/10/2015}. In June 2008, Mozilla added support for contentEditable IDL and contenteditable content attributes with Firefox 3. 

Mozilla's editing API mostly resembles the API implemented for Internet Explorer, however, to this present day, there are still differences (compare\footnote{\url{https://msdn.microsoft.com/en-us/library/hh772123(v=vs.85).aspx}, last checked on 07/10/2015}\footnote{\url{https://developer.mozilla.org/en-US/docs/Midas}, last checked on 07/10/2015}). This includes the available command identifiers \footnote{\url{https://developer.mozilla.org/en-US/docs/Midas}, last checked on 07/10/2015}\footnote{\url{https://msdn.microsoft.com/en-us/library/ms533049(v=vs.85).aspx}, last checked on 07/10/2015} as well as the markup generated by invoking commands\footnote{\url{https://developer.mozilla.org/en/docs/Rich-Text\_Editing\_in\_Mozilla#Internet\_Explorer\_Differences}, last checked on 07/10/2015}. 

%% Mozilla's command identifiers are restricted to text-editing command, showing the clear purpose of this API.

%% This may show, that even though rich-text editing was its first use case and Mozilla implemented it naming it that, this editing API was not originally intended to be used as such.

In March 2008, Apple released Safari 3.1\footnote{\url{https://www.apple.com/pr/library/2008/03/18Apple-Releases-Safari-3-1.html}, last checked on 07/10/2015} including full support for contentEditable and designMode\footnote{\url{http://caniuse.com/#feat=contenteditable}, last checked on 07/10/2015}, followed by Opera Software in June 2006\footnote{\url{http://www.opera.com/docs/changelogs/windows/}, last checked on 07/10/2015} providing full support in Opera 9\footnote{\url{http://www.opera.com/docs/changelogs/windows/900/}, last checked on 07/10/2015}. MDN lists full support in Google Chrome since version 4\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content\_Editable}, last checked on 07/10/2015}, released in January 2010\footnote{\url{http://googlechromereleases.blogspot.de/2010/01/stable-channel-update\_25.html}, last checked on 07/10/2015}.

Starting in November 2004, WHATWG members have started actively discussing to incorporate these editing APIs in the HTML5 standard. Through reverse engineering, the WHATWG developed a specification based on Microsoft's implementation\footnote{\url{https://blog.whatwg.org/the-road-to-html-5-contenteditable}, last checked on 07/15/2015} and finally decided to include it in HTML5. With W3C's coorporation and the split in 2011, similar editing APIs based on this work are now included in W3C's HTML5 Standard\footnote{\url{http://www.w3.org/TR/html5/editing.html}, last checked on 07/15/2015} and WHATWG's HTML Standard\footnote{\url{https://html.spec.whatwg.org/multipage/interaction.html#editing-2}, last checked on 07/15/2015}.

\subsection{Emergence of HTML editing JavaScript libraries}

Around the year 2003\footnote{compare \textit{Meine Tabelle aller Editoren}} the first JavaScript libraries emerged that made use of Microsoft's and Mozilla's editing mode to offer rich-text editing in the browser. Usually these libraries were released as user interface components (text fields) with inherent rich-text functionality and were only partly customizable.

In May 2003 and March 2004 versions 1.0 of ''FCKEditor''\footnote{Now distributed as ''CKEditor''} and ''TinyMCE'' have been released as open source projects. These projects are still being maintained and remain among the most used editors for incorporating rich-text editing in web-based projects. TinyMCE is the default editor for Wordpress and CKEditor is listed as the most popular rich-text editor for Drupal\footnote{\url{https://www.drupal.org/project/project\_module}, last checked on 07/16/2015}. 

Since the introduction of Microsoft's HTML editing APIs, a large number of rich-text editors have been implemented. While many have been abandoned, GitHub lists about 600 JavaScript projects related to rich-text editing. However, it is to be noted, that some projects only use other projects' editors and some projects are stubs. Popular choices on GitHub\footnote{\url{https://github.com/search?o=desc\&q=wysiwyg\&s=stars\&type=Repositories\&utf8=\%E2\%9C\%93}, last checked on 07/16/2015} include ''MediumEditor'', ''wysihtml'', ''Summernote'' and others.


\subsection{Usage of HTML Editing APIs}
\label{sec:useage-of-html-editing-apis}

How Js Libraries work. Maybe how only a few work. StackOverlfow quote, buglists, Medium post, other stuff to find.

Seeing how editing APIs have come to existance, as an undocumented API by microsoft, taken over by mozilla, bossted by JS libraries and then adopted by other browsers, it can be understood how editing APIs came to be. However, by its introduction by microsoft, it has not been stated that this has been its original purpose. And even if Mozilla picked up on it, it is not clear that this API is in fact the best way to implement rich-text editing. WHATWG has discussed this API, arguing if it is the best way to provide rich-text functionality.

** WICHTIG DEN BOGEN ZU SPANNEN WARUM ICH ÜBER DIE GESCHICHTE SCHREIBE** ERKLÄREN, DASS ALLE DIE API VON MICROSOFT ÜBERNOMMEN HABEN; ANSTATT RICH-TEXT ELEMENTE EINZUFÜHREN. HTML5 HAT KOMPONENTEN FÜR TIME UND DATE; WARUM NICHT RICH TEXT- WHATWG HAT DAS DISCUSSED. WAS WAREN DIE GRÜNDE?. BEI DER BESCHREIBUNG DARAUF ACHTEN DASS ICH DEN GRUND GEBE; WARUM ICH DIE ENTWICKLUNG SO LANGE ERKLÄRE. VIELLEICHT AUCH SAGEN, DASS TROTZ DASS HTML5 ERST SEIT X RELEASED WURDE, ANHAND DER GESCHICHTE GESEHEN WERDEN KANN; DASS ES SCHON LANGE BROWSER SUPPORT GIBT.

Seeing the history of editing APIs, it is understandable how this has become the standard for rich-text editing. However, with its introduction in Internet Explorer 5.5, it has not been stated that the \texttt{designMode} end \texttt{contentEditable} attributes have been intended to enable rich-text editing. Sections X and Y will discuss the advantages and disadvantages of these APIs.

% Rich-text editing in browsers is only possible though JavaScript. Essentially, libraries enabling rich-text editing display a nested webpage through an iFrame and let the user modify its contents to emulate a rich-text input. Commonly, modification is realized though the browser's so-called ''HTML Editing APIs'', which will be discussed in Section XXX (HTML Editing APIs).

\subsection{Advantages of HTML Editing APIs}

Higlevel API
Wenig Aufwand
discussion of WHATWG

\subsection{Disadvantages of HTML Editing APIs}

bugs
it seems to me the api as provided is a bad idea. Programmers can handle control, and why not make this control specific instead of executing bulkish commands.
very limited api. limited wo a few commands and a few paramters
No specifications on what markup to generate (mozilla != ie, mdn has links for that)
\paragraph{pasting}
is a problem: shitty markup can be pasted, paste event not implemented in all browser, some offer a modal, some clean up after change. I can solve this problem.

\subsection{DOM manipulation without Editing APIs}

In October 1998 the World Wide Web Consortium (W3C) published the ''Document Object Model (DOM) Level 1 Specification''. This specification includes an API on how to alter DOM nodes and the document's tree\footnote{\url{http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html}, last checked on 07/10/2015}. It provided a standardized way for changing a website's contents. With the implementations of Netscape's JavaScript and Microsoft's JScript this API has been made accessible to web developers.

\subsection{Advantages of rich-text editing without Editing APIs}

Only this can guarantee the same behaviour and the same output across all browsers.
It puts the contenteditable implementation in the hand of JavaScript developers. We no longer have to wait for browsers to fix issues *and conform each other* and thus can be faster, at least possibly, than browsers are.
Also we can deploy updates immediately to all users and do not have to worry they use old browsers even if updates exist.

\subsection{Disadvantages of rich-text editing without Editing APIs}

Apparently implementing editing is prone to a lot of bugs issues **and edge-casese**. It can be assumed that it is difficult to do so. / Discuss the issues discussed by WHATWG here. It's difficult to do this.

Also this can be seen as ''yet another'' implementation of contenteditable, equal to browser implementations. Just one more editor for developers to take care of. However, this isn't quite correct, cos developers usually can choose a single editor that is used for the entire project, so they only have to take care of a single editor.

\subsection{Disadvantages of offering user interface components}

Warum es besser ist eine library zu shippen und nicht einen editor als ui component

