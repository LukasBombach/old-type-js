%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Implementation}

\section{Conformity with HTML Editing APIs}
Wie sehr passt meine library zu dein HTML Editing APIs
Was definieren die?
Was muss ich conformen, welche Freiheiten habe ich?
https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html

\section{Goals}

\paragraph{Minimze interaction with the DOM} DOM operations are slow and should be avoided.

\paragraph{Minimze interaction with unstable APIs} Some APIs like the \texttt{Range} or \texttt{Selection} are prone to numerous bugs. To maximize stability, these APIs should be avoided when possible unless doing so has any downsides (like lower performance).

\paragraph{Markup} Our editor should be a good citizen in this ecosystem. That means we ought to produce HTML that’s easy to read and understand. And on the flip side, we need to be aware that our editor has to deal with pasted content that can’t possibly be created in our editor. https://medium.com/medium-eng/why-contenteditable-is-terrible-122d8a40e480

\section{JavaScript library development}

No IDEs, tools, not even conventions.

Not for building:
Big JS libraries all do it differently.
Top 3 client side JavaScript repositories (stars) on github
https://github.com/search?l=JavaScript\&q=stars\%3A\%3E1\&s=stars\&type=Repositories
Angular.js: Grunt
d3 Makefile, also ein custom build script welche node packages aufruft
jQuery custom scripts, mit grunt und regex und so

Not for Architecture
Angular custom module system with own conventions
d3 mit nested objects (assoc arrays) und funktionen
jQuery mit .fn
ACE mit Klassen, daraus habe ich gelernt


\section{Ich habe verwendet}

Gulp
requireJs
AMDClean
Uglify

JSLint - Douglas Crockford coding dogmatas / conventions
JSCS - JavaScript style guide checker

~~Livereload~~
PhantomJs
Mocha
Chai

Durch Require und AMDClean schöne arbeitsweise (am ende über bord geworfen) und kleine Dateigröße, wenig overhead.

Automatisierte Client side Tests mit PhantomJs und Mocha/Chai


\section{Coding conventions}

Habe mich größtenteils an Crockfordstyle orientiert, aber die Klassen anders geschrieben. Habe den Stil von ACE editor verwendet, denn der ist gut lesbar. Lesbarkeit war mir wichtiger als Crockford style. Für private Eigenschaften und Methoden habe ich die prefix convention verwedendet.
https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor\_s\_Guide/Private\_Properties
Sie bewirkt keine echte accessibility restriction, aber es ist eine allgemein anerkannten convention und ist auch viel besser lesbar.

\section{Coding Klassen}

Ich habe mich für Klassen entschieden. Das hat folgende Vorteile:

* Klassen sind ein bewährtes Konzept um Code zu kapseln, logisch zu strukturieren und lesbar zu verwalten
* Durch prototypische Vererbung existiert die funktionalität von Klassen nur 1x im Browser 7 RAM
* Zudem gibt es Instanzvariablen, die für jede Type Instanz extra existieren und so mehrere Instanzen erlauben
* Die instanzvariablem sind meistens nur Pointer auf Instanzen anderer Klassen
* Das ganze ist dadurch sehr schlank

\section{Programmstruktur}

Es gibt ein Basisobjekt, das ist die Type "Klasse".
Darin werden dann die anderen Klassen geschrieben "Type.Caret", "Type.Selection", "Type.Range", ...
Das hat den Vorteil dass das ganze ge-name-spaced ist, so dass ich keine Konflikte mit Systemnamen habe (Range) (und auch nicht mit anderen Bibliotheken)
Effektiv gibt es eine (flache) Baumstruktur und so mit Ordnung. Für bestimmte Klassen, "Type.Event.Input", "Type.Input.Filter.X" geht es tiefer.
Der zweite Grund ist, dass ich somit alle Klassen die ich geschrieben habe für Entwickler sichtbar bereit stelle und nicht implizit und versteckt über irgend nen Quatsch.

Ursprünglich ein MVC konzept geplant mit einem Document Model und verschiedenen Renderern, aber über den haufen geworfen.

Ich werde jetzt die einzelnen Module erlären


\section{Type}

Die Type

\section{Caret}
caret
\section{Range}
range
\section{Selection}
selection
\section{Selection Overlay}
overlay
\section{Input}
input
82.78\% of internet users support listening to and reading clipboard events. I can support 100\% PROBLEMS
\section{Formatting}
formatting
\section{Change Listener}
change
\section{Contents}
contents
\section{Development}
developmnent
\section{Dom Utilities}
dom util
\section{Dom Walker}
dom walker
\section{Environment}
env
\section{Core Api}
core api
\section{Event Api}
ev api

\section{Events}
\paragraph{Input}
input event only event required so far

\section{Input Pipeline}
pipeline ideas
\paragraph{Caret}
caret
\paragraph{Command}
command
\paragraph{Headlines}
head lines
\paragraph{Line Breaks}
line breaks
\paragraph{Lists}
lists
\paragraph{Remove}
remove
\paragraph{Spaces}
spaces

\section{Plugin Api}
plugin api
\section{Settings}
settings
\section{Text Walker}
text walker
\section{Utilities}
util