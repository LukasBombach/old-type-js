%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Implementation}

\section{JavaScript library development}

No IDEs, tools, not even conventions.

Not for building:
Big JS libraries all do it differently.
Top 3 client side JavaScript repositories (stars) on github
https://github.com/search?l=JavaScript\&q=stars\%3A\%3E1\&s=stars\&type=Repositories
Angular.js: Grunt
d3 Makefile, also ein custom build script welche node packages aufruft
jQuery custom scripts, mit grunt und regex und so

Not for Architecture
Angular custom module system with own conventions
d3 mit nested objects (assoc arrays) und funktionen
jQuery mit .fn
ACE mit Klassen, daraus habe ich gelernt


\section{Ich habe verwendet}

Gulp
requireJs
AMDClean
Uglify

JSLint - Douglas Crockford coding dogmatas / conventions
JSCS - JavaScript style guide checker

~~Livereload~~
PhantomJs
Mocha
Chai

Durch Require und AMDClean schöne arbeitsweise (am ende über bord geworfen) und kleine Dateigröße, wenig overhead.

Automatisierte Client side Tests mit PhantomJs und Mocha/Chai


\section{Coding conventions}

Habe mich größtenteils an Crockfordstyle orientiert, aber die Klassen anders geschrieben. Habe den Stil von ACE editor verwendet, denn der ist gut lesbar. Lesbarkeit war mir wichtiger als Crockford style. Für private Eigenschaften und Methoden habe ich die prefix convention verwedendet.
https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor\_s\_Guide/Private\_Properties
Sie bewirkt keine echte accessibility restriction, aber es ist eine allgemein anerkannten convention und ist auch viel besser lesbar.

\section{Coding Klassen}

Ich habe mich für Klassen entschieden. Das hat folgende Vorteile:

* Klassen sind ein bewährtes Konzept um Code zu kapseln, logisch zu strukturieren und lesbar zu verwalten
* Durch prototypische Vererbung existiert die funktionalität von Klassen nur 1x im Browser 7 RAM
* Zudem gibt es Instanzvariablen, die für jede Type Instanz extra existieren und so mehrere Instanzen erlauben
* Die instanzvariablem sind meistens nur Pointer auf Instanzen anderer Klassen
* Das ganze ist dadurch sehr schlank

\section{Programmstruktur}

Es gibt ein Basisobjekt, das ist die Type "Klasse".
Darin werden dann die anderen Klassen geschrieben "Type.Caret", "Type.Selection", "Type.Range", ...
Das hat den Vorteil dass das ganze ge-name-spaced ist, so dass ich keine Konflikte mit Systemnamen habe (Range) (und auch nicht mit anderen Bibliotheken)
Effektiv gibt es eine (flache) Baumstruktur und so mit Ordnung. Für bestimmte Klassen, "Type.Event.Input", "Type.Input.Filter.X" geht es tiefer.
Der zweite Grund ist, dass ich somit alle Klassen die ich geschrieben habe für Entwickler sichtbar bereit stelle und nicht implizit und versteckt über irgend nen Quatsch.

Ursprünglich ein MVC konzept geplant mit einem Document Model und verschiedenen Renderern, aber über den haufen geworfen.

Ich werde jetzt die einzelnen Module erlären


\section{Type}

Die Type

\section{Caret}
caret
\section{Range}
range



\section{Input}

%82.78\% of internet users support listening to and reading clipboard events. I can support 100\% PROBLEMS

There are many devices (hardware and virtual) a user can interact with native inputs:

\begin{enumerate} 
\item Keyboard (as hardware and as virtual keyboard)
\item Mouse
\item Touch
\item Remote control (on SmartTv einvironments)
\end{enumerate}

When simulating a native input, in a best-case scenario, all these input methods should be accounted for. Fetching input needs to account for two scenarios: The user clicks / touches / or selects the input in any way and does so at any position inside the input. If the user touches / clicks / etc in the middle of the text, the caret should move to that position and typing must be enabled. In environments without hardware keyboards, the libarary must ensure that a virutal keyboards, possible native to the system, show up. Once the input is selected, text input must be fetched and written to the editor. There are various options to fetch user input, which will be discussed in the following paragraphs:

\paragraph{Events} One way to fetch user input is by listening to events. Text input can be read through keyboard events. Keyboard events will be triggered for virtual keyboards just as for hardware keyboards. When the user presses a key, the event can be stopped and the according characters can be inserted at the position of the caret. As a downside, listeners for keyboard events cannot be bound to a specific element that is not a native text input, that means keyboard events must be listened to on the \texttt{document} level. This not only has (minor) performance downsides but als requires more logic to decide whether a keyboard input should be processed and ultimatively stopped or ignored and allowed to bubble to other event listeners of a website. Furthermore, there can be edge cases, where even though a keyboard event should write contents to the editor, the event itself is supposed to trigger other methods that are not part of the editor.

\paragraph{Clipboard} 

\section{Selection}


\section{Selection Overlay}
overlay

\section{Formatting}
formatting
\section{Change Listener}
change
\section{Contents}
contents
\section{Development}
developmnent
\section{Dom Utilities}
dom util
\section{Dom Walker}
dom walker. Used SO OFTEN in the project. Goal is to have a really simple api new DomWalker('text') by having lots of pre-defined magick in it.
\section{Environment}
env
\section{Core Api}
core api
\section{Event Api}
ev api

\section{Events}
\paragraph{Input}
input event only event required so far

\section{Input Pipeline}
pipeline idea
rules for behaviours (lists, headlines, enter, spaces...)
\paragraph{Caret}
caret
\paragraph{Command}
command
\paragraph{Headlines}
head lines
\paragraph{Line Breaks}
line breaks
\paragraph{Lists}
lists
\paragraph{Remove}
remove
\paragraph{Spaces}
spaces

\section{Plugin Api}
plugin api
\section{Settings}
settings
\section{Text Walker}
text walker
\section{Utilities}
util

\section{Extensions}

Collaboration with etherpad, Markdown wohl eher als Ausblick.
