{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0     // move through elements until endcontainer is reached\
    // or end of parent element is reached\
    // include everything in between\
\
    // then find next sibling of parent (parent's parent etc)\
    // and repeat this method\
\
    // ----\
\
    // other idea\
    // iterate over siblings\
    // if endNode (endContainer) is found, wrap including part of endcontainer 
\f1 \uc0\u10003 
\f0 \
\
    // if node parent to endNode is found, wrao until before that node and apply this method to first textNode in there\
    // What do with\
\
    // if node parent to end is found, wrap till before that and apply this method to that node\
    // if end of parent is found wrap find next sibling to parent\
\
\
    // ---\
\
    // Immer siblings iterieren und wrappen. bis man den sibling findet der das ding als child hat\
    // -> note: selbst wenn letzteres ein einfaches <u>endNode<u> element ist, wird es als node.contains(endNode) gefunden\
    // Wenn der node.contains(endNode) gefunden wurde, bei seinem ersten ChildNode anfangen und den selben algorithmus ausf\'fchren\
\
    // Deswegen sollte _insert irgendwie mit elementen arbeiten und nicht mit textnodes\
    // TextNodes sind auch einfach nur nodes, von daher muss man es nur als sonderfall betrachten wenn currentNode = startContainer\
}